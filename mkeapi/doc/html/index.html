<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MkE API v1.0: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="mke-banner.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MkE API v1.0
   </div>
   <div id="projectbrief">Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_mkeapi_README"></a></p>
<p>This document describes the Magik Eye API of version 1.0 (hereinafter referred to as the <em>MkE API</em>): the application programming interface that defines the communication between the Magik Eye depth sensor (hereinafter referred to as the <em>sensor</em>) and the sensors' user.</p>
<p>This document is divided into four parts. The first part describes the operational states of the sensor. The second part describes the communication protocol between the sensor and the sensor’s user (hereinafter referred to as the <em>client</em>). The third part describes the data format of the 3D data provided by the sensor. The last part of this documents provides the full API reference.</p>
<p><img src="figs/api_states.png" alt="Sensor states" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Sensor States</h1>
<p>The sensor has two main states of operation, see <a href="#apistates">Figure 1</a>. After booting, the sensor will automatically move to the state <code>MKE_STATE_IDLE</code>. In this state, no 3D sensing is performed and the sensor consumes only limited power resources. In order to provide 3D measurements, the sensor needs to pass to the state <code>MKE_STATE_DEPTH_SENSOR</code>. In this state, the sensor computes the depth information and, upon request, provides this information to the client. The sensor can be, at any time, powered off or rebooted by passing it into the (pseudo) state <code>MKE_STATE_TERMINATE</code>. Optionally, the sensor can once again pass to the power saving <code>MKE_STATE_IDLE</code> state. The sensor and its client communicate by exchanging data packets called requests and replies. <a href="#apistates">Figure 1</a> lists the request types available in each of the sensor’s states.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Communication Protocol</h1>
<p>The communication protocol between the sensor and the client is based on the client-server model. The client sends a fixed size data packet, a <em>request</em>, and the server (sensor) responds with variable-sized data packets, <em>replies</em>: </p><pre class="fragment"> Client                     Server
 ---------------------------------
 Request     -----------&gt;
            &lt;-----------      Reply
</pre><p> Both request and reply contain a human readable textual part and a binary part, where any parameters and payload data are contained.</p>
<p>Note that all data is interpreted by the sensor using the <em>little endian encoding</em>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Transport Layer</h2>
<p>The MkE API describes the application layer of the communication protocol between the sensor and the client. The lower layers of the sensor-client communication are sensor specific. Practically, there are two main methods the client can use to physically connect to the sensor. The first is the UART interface, where no transport layer is needed. The second method is Ethernet where the TCP protocol is used as the transport layer. In the case the TCP connections are supported by a sensor, the MkE API server will usually listen on the port 8888.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Network Discovery</h2>
<p>When Ethernet and TCP connections are supported by a sensor, the sensor can also optionally implement SSDP (Simple Service Discovery Protocol) for advertisement and discovery. SSDP is an internet standard and a part of UPnP (Universal Plug and Play) standard. The USN (Unique Service Name) URI of a MagikEye sensor will always contain "MkE" as a substring.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Request</h2>
<p>The client request data packet is <em>always at least</em> 24 bytes long. The following C-style structure describes the inner structure of the request data packet:</p>
<div class="fragment"><div class="line">struct MkERequest {</div>
<div class="line">  char magik[8];</div>
<div class="line">  char type[4];</div>
<div class="line">  uint32_t reqid;</div>
<div class="line">  MkERequest_Params params;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest</code> fields have the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>char magik[8]</code>   </td><td class="markdownTableBodyNone">MkE API request packet identifier, must be set to: <code>MKERQ100</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>char type[4]</code>   </td><td class="markdownTableBodyNone">Request type as a zero padded decimal string, e.g., <code>0020</code> for request type 20, see <a href="#subsec_request_types">Request Type</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t reqid</code>   </td><td class="markdownTableBodyNone">ID number of a request. A respective response will have the same ID.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MkERequest_Params params</code>   </td><td class="markdownTableBodyNone">8 -byte long data structure describing the respective MkE API request parameters.   </td></tr>
</table>
<p>Note that the API does not enforce any special values or sequence of data passed by <code>reqid</code> ID. This identification will simply be a part of the sensor’s response. It is up to the client to decide if and how to use this information.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Reply</h2>
<p>The sensor reply data packet is <em>always at least</em> 48 bytes long. The following C-style structure describes the inner structure of the first 48 bytes of the reply:</p>
<div class="fragment"><div class="line">struct MkEReply {</div>
<div class="line">  char magik[8];</div>
<div class="line">  char type[4];</div>
<div class="line">  char status[4];</div>
<div class="line">  uint32_t reqid;</div>
<div class="line">  uint32_t num_bytes;</div>
<div class="line">  MkEReply_params params;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply</code> fields have the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>char magik[8]</code>   </td><td class="markdownTableBodyNone">MkE API reply packet identifier. Must be set to: <code>MKERP100</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>char type[4]</code>   </td><td class="markdownTableBodyNone">Request type of the original Mke API request that this data packet replies to, e.g., <code>0020</code> for request type 20.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>char status[4]</code>   </td><td class="markdownTableBodyNone">Reply status as a zero padded decimal string, e.g., <code>0200</code> for <code>MKE_REPLY_OK</code>, see <a href="#subsec_reply_status">Reply Status</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint32_t reqid</code>   </td><td class="markdownTableBodyNone">ID number of a request that this data packet replies to.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t num_bytes</code>   </td><td class="markdownTableBodyNone">Size of the additional payload data directly following this reply. If there is no additional payload, this must be set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MkEReply_params params</code>   </td><td class="markdownTableBodyNone">24-bytes long data structure describing the respective MkE API reply parameters.   </td></tr>
</table>
<p>The <code>num_bytes</code> field indicates that an appropriate number of bytes will directly follow the first 48 bytes of the reply.</p>
<p>Note that since each request may vary in its processing time by the sensor, there is no guarantee that replies will arrive in the same order as requests were sent by the client. It is up to the client to account for this fact, e.g., using the <code>reqid</code> field.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Examples</h2>
<p>This section presents several examples of client and server data packet exchanges.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Querying the Sensor State</h3>
<p>Let us assume that the sensor was just powered on. After the booting process, the sensor will pass into the <code>MKE_STATE_IDLE</code> state. As a user, you can check this by quering the sensor via the request <code>MKE_REQUEST_GET_STATE</code> (numerical code 20), see [](#subsec_mke_request_get_state). The <code>MKE_REQUEST_GET_STATE</code> request type, together with <code>reqid</code> set to <code>0A</code>, lead to the following request data packet: </p><pre class="fragment">00000000  4D 4B 45 52 51 31 30 30 30 30 32 30 MKERQ1000020
0000000C  0A 00 00 00 00 00 00 00 00 00 00 00 ............
</pre><p> Here, the first number in the row specifies the hexadecimal data offset, followed by 12 data bytes. This is followed by the same 12 data bytes interpreted as an ASCII string. To such a request, the sensor will reply with the following data packet: </p><pre class="fragment">00000000  4D 4B 45 52 50 31 30 30 30 30 32 30 MKERP1000020
0000000C  30 32 30 30 0A 00 00 00 00 00 00 00 0200........
00000018  01 00 00 00 00 00 00 00 00 00 00 00 ............
00000024  00 00 00 00 00 00 00 00 00 00 00 00 ............
</pre><p> Here, the sensor replied to the request of type <code>MKE_REQUEST_GET_STATE</code> and <code>reqid</code> set to <code>0x0A</code> with the reply status <code>MKE_REPLY_OK</code> (Numerical code 200), indicating that the request was successfully handled. Further, it provided the response via the <code>params</code> part of the reply data packet as <code>MKE_STATE_IDLE</code> (numerical code 1).</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Setting the Sensor State</h3>
<p>To change the sensor state from <code>MKE_STATE_IDLE</code> to <code>MKE_STATE_DEPTH_SENSOR</code>, use the <code>MKE_REQUEST_SET_STATE</code> request type (numerical code 21), see [](#subsec_mke_request_set_state). Assuming we incremented <code>reqid</code> to <code>0x0B</code>, the corresponding request data packet will look like this: </p><pre class="fragment">00000000  4D 4B 45 52 51 31 30 30 30 30 32 31 MKERQ1000021
0000000C  0B 00 00 00 02 00 00 00 00 00 00 00 ............
</pre><p> If all goes well, the sensor will readily reply with the following data packet with reply status <code>MKE_REPLY_OK</code>: </p><pre class="fragment">00000000  4D 4B 45 52 50 31 30 30 30 30 32 31 MKERP1000021
0000000C  30 32 30 30 0B 00 00 00 00 00 00 00 0200........
00000018  00 00 00 00 00 00 00 00 00 00 00 00 ............
00000024  00 00 00 00 00 00 00 00 00 00 00 00 ............
</pre> <h3><a class="anchor" id="autotoc_md9"></a>
Powering Off the Sensor</h3>
<p>To request a physical shutdown of the sensor, use <code>MKE_REQUEST_TERMINATE</code> request type (numerical code 10) with parameter <code>method</code> set to <code>MKE_TERMINATE_BY_SHUTDOWN</code>, see [](#subsec_mke_request_terminate). Assuming we once again incremented the <code>reqid</code> to <code>0x0C</code>, the corresponding request data packet will look like this: </p><pre class="fragment">00000000  4D 4B 45 52 51 31 30 30 30 30 31 30 MKERQ1000010
0000000C  0C 00 00 00 02 00 00 00 00 00 00 00 ............
</pre><p> The sensor will reply with <code>MKE_REPLY_OK</code> status in the case it registered the request and is on its way to perform the termination action. Of course, it cannot confirm a successful shutdown after termination action is completed.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
3D Data</h1>
<p>Once the sensor is in the <code>MKE_STATE_DEPTH_SENSOR</code> state, it is ready to provide 3D measurements to the client. The 3D data is provided as a reply data payload, which is in this context called a <em>frame</em>. There are two ways the client can decide to request frames:</p>
<ul>
<li>by <em>client polling</em> via <code>MKE_REQUEST_GET_FRAME</code> request, or</li>
<li>by <em>sensor pushing</em> via <code>MKE_REQUEST_(START|STOP)_FRAME_PUSH</code> requests.</li>
</ul>
<p>The frame itself consists of a variable number of <em>frame items</em>&ndash;which conceptually correspond to detections, i.e., 3D points—​and a <em>frame footer</em>, containing the CRC-32 checksum (ITU-T V.42) of the whole frame. There are two types of data items: <code>MKE_FRAME_TYPE_1</code> and <code>MKE_FRAME_TYPE_2</code>.</p>
<p><img src="figs/sensor_axes.png" alt="An example of sensor axes placement" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md11"></a>
3D Data Frame</h2>
<p>If a reply data packet contains a data payload, it signals the same via the non-zero reply field <code>num_bytes</code>, see <a href="#subsec_reply">Reply</a>. This allows the client to wait for the appropriate number of bytes before attempting to parse its contents. As it is practically impossible to detect all theoretical detection points in each image captured by the sensor’s camera, the values of <code>num_bytes</code> fields of reply packets carrying frames will generally differ. This will depend on the number of 3D points the sensor was able to recover for each given camera image.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
&lt;tt&gt;MkEReply&lt;/tt&gt; Parameters</h3>
<p>A frame-carrying reply 24-byte field <code>params</code> has a specific structure described by the following C-style structure:</p>
<div class="fragment"><div class="line">struct MkEReply_Frame {</div>
<div class="line">  uint64_t timer;</div>
<div class="line">  uint64_t seqn;</div>
<div class="line">  uint32_t data3d_type;</div>
<div class="line">  uint16_t frame_type;</div>
<div class="line">  uint16_t num_data;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_Frame</code> fields have the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint64_t timer</code>   </td><td class="markdownTableBodyNone">Time of the end of the camera image exposure in milliseconds elapsed from the boot. This can be used to measure time elapsed between different frame exposures.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint64_t seqn</code>   </td><td class="markdownTableBodyNone">Sequence number of a frame. This counter is incremented every time a frame is successfully processed by the sensor in the <code>MKE_STATE_DEPTH_SENSOR</code> state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t data3d_type</code>   </td><td class="markdownTableBodyNone">Determines the units of the 3D coordinates of the frame items. Currently, there are five possible types, see <a href="#subsec_3d_data_types">3D Data Types</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint16_t frame_type</code>   </td><td class="markdownTableBodyNone">Determines the frame item type: either <code>MKE_FRAME_TYPE_1</code> (numerical code 1) or <code>MKE_FRAME_TYPE_2</code> (numerical code 2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t num_data</code>   </td><td class="markdownTableBodyNone">Number of frame items.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md13"></a>
3D Data Types</h3>
<p>Currently, there are five possible 3D data types (units) that the sensor can use to encode the 3D coordinate values. The 3D data type is determined by the sensor and cannot be changed by an <code>MkERequest</code>. However, it is possible for the sensor to change the 3D data type during its operations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Type</em>   </td><td class="markdownTableBodyNone"><em>Value</em>   </td><td class="markdownTableBodyNone"><em>Units</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_DATA3D_MM</code>   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">1 millimeter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_DATA3D_MM2</code>   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">1/2 millimeter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_DATA3D_MM4</code>   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">1/4 millimeter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_DATA3D_MM8</code>   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">1/8 millimeter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_DATA3D_MM16</code>   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">1/16 millimeter   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md14"></a>
Frame Items</h3>
<p>Immediately after the first 48 bytes of <code>MkEReply</code> follow the <code>num_data</code> frame items. Every item in a given frame has the item type given by the <code>frame_type</code> field.</p>
<p>The following C-style structure <code>MkEFrameItem1</code> describes the inner structure of frame item type <code>MKE_FRAME_TYPE_1</code>:</p>
<div class="fragment"><div class="line">struct MkEFrameItem1 {</div>
<div class="line">  uint16_t uid;</div>
<div class="line">  int16_t  x, y, z;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEFrameItem1</code> frame item is 8 bytes long and its fields have the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t uid</code>   </td><td class="markdownTableBodyNone">Universal ID key of the detection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int16_t x, y, z</code>   </td><td class="markdownTableBodyNone">3D coordinates of the detection in the units determined by <code>data3d_type</code> in the coordinate system connected with the sensor, see <a href="#sensor_axes">Figure 2</a>.   </td></tr>
</table>
<p>The following C-style structure <code>MkEFrameItem2</code> describes the inner structure of frame item type <code>MKE_FRAME_TYPE_2</code>:</p>
<div class="fragment"><div class="line">struct MkEFrameItem2 {</div>
<div class="line">  uint16_t uid;</div>
<div class="line">  int16_t  x, y, z;</div>
<div class="line">  uint16_t lid, did;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEFrameItem2</code> frame item is 12 bytes long and its fields have the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t uid</code>   </td><td class="markdownTableBodyNone">Universal ID key of the detection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int16_t x, y, z</code>   </td><td class="markdownTableBodyNone">3D coordinates of the detection in the units determined by <code>data3d_type</code> in the coordinate system connected with the sensor, see <a href="#sensor_axes">Figure 2</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t lid, did</code>   </td><td class="markdownTableBodyNone">Reserved for future use.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md15"></a>
Frame Footer</h3>
<p>Finally, immediately after the last frame item follows the frame footer:</p>
<div class="fragment"><div class="line">struct MkEFrameFooter {</div>
<div class="line">  uint32_t crc32;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEFrameFooter</code> structure has only one field as below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t crc32</code>   </td><td class="markdownTableBodyNone">CRC-32 check (ITU-T V.42) of the frame items bytes.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md16"></a>
Example</h3>
<p>Let us inspect the following reply data packet: </p><pre class="fragment">00000000  4D 4B 45 52 50 31 30 30 30 30 32 36 MKERP1000026
0000000C  30 32 30 30 01 00 00 00 24 00 00 00 0200....$...
00000018  AD 0D AC BA 00 00 00 00 02 00 00 00 ............
00000024  00 00 00 00 00 00 00 00 01 00 04 00 ............
00000030  07 00 AE FF E4 FF 4F 00 0B 00 A1 FF ......O.....
0000003C  E4 FF 40 00 0C 00 B7 FF E5 FF 56 00 ..@.......V.
00000048  12 00 A8 FF E4 FF 47 00 99 38 6B BA ......G..8k.
</pre><p> We can see that this data packet is a successful reply, <code>MKE_REPLY_OK</code> (numerical code 200), to a <code>MKE_REQUEST_GET_FRAME</code> (numerical code 26) request, see [](#subsec_mke_request_get_frame), with <code>reqid</code> = 1. Now, because this data is a reply to <code>MKE_REQUEST_GET_FRAME</code>, we should interpret the reply <code>params</code> as <code>MkEReply_Frame</code>. Here, the fields of <code>MkEReply_Frame</code> have the following values: <code>timer</code> = <code>0xBAAC0DADul</code> = 3131837869, <code>seqn</code> = 2, <code>frame_type</code> = <code>MKE_FRAME_TYPE_1</code>=1, and <code>num_data</code> = 4.</p>
<p>Besides the 48 bytes of <code>MkeReply</code>, the data packet also contains <code>num_bytes</code> = 36 bytes of additional data payload. This corresponds to <code>num_data</code> = 4 times 8 bytes of <code>MkeFrameItem1</code>, plus 4 bytes of <code>MkEFrameFooter</code>. The frame parses into four 3D points (-82, -28, 79), (-95, -28, 64), (-73, -27, 86), and (-88, -28, 71) with four respective IDs 7, 11, 12, and 18. Finally, the frame ends with CRC-32 checksum <code>crc32</code> = <code>0xBA6B3899u</code>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Requesting Frames</h2>
<p>Requesting a single frame from the sensor is quite straightforward. First, the sensor must be in the <code>MKE_STATE_DEPTH_SENSOR</code> state. Then, to a request of type <code>MKE_REQUEST_GET_FRAME</code>, see [](#subsec_mke_request_get_frame), the sensor responds with a single reply data packet. The reply status <code>MKE_REPLY_OK</code> determines that this data packet carries a valid frame.</p>
<p>To receive a stream of frames from the sensor, one can simply place the <code>MKE_REQUEST_GET_FRAME</code> request call into a loop. Since the sensor will not respond to <code>MKE_REQUEST_GET_FRAME</code> request <em>before</em> a new frame is available, it is guarantied that a client that waits for a sensor’s reply to such a call before sending another request will never receive the same frame twice. On the other hand, if the client does not request the next frame in time, maybe because it spent too much time processing the current one, it is possible it will miss the chance to receive it and it will receive a frame after that instead. To detect such situations, differences of the respective fields <code>timer</code> and <code>seqn</code> from subsequent `MkEReply_Frame’s can be used.</p>
<p>Another way to receive a stream of frames is via the <code>MKE_REQUEST_START_FRAME_PUSH</code> request. Once the sensor receives this request, it will automatically send every subsequent available frame. To tell the sensor to stop the frame stream, the client must send the <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request. The following diagram explains this communication scheme in more detail: </p><pre class="fragment"> Client's Request              Sensor's Reply
 --------------------------------------------------------------
 MKE_REQUEST_START_FRAME_PUSH
   (reqid = 1)
                               MKE_REPLY_DATA_WILL_START
                                 (reqid = 1)
                               MKE_REPLY_DATA_WILL_CONTINUE
                                 (reqid = 1, frame data)
                               ...
                               MKE_REPLY_DATA_WILL_CONTINUE
                                 (reqid = 1, frame data)
 MKE_REQUEST_STOP_FRAME_PUSH
   (reqid = 2)
                               ...
                               MKE_REPLY_DATA_WILL_CONTINUE
                                 (reqid = 1, frame data)
                               MKE_REPLY_OK
                                 (reqid = 2)
                               MKE_REPLY_DATA_STOPPED
                                 (reqid = 1)
 --------------------------------------------------------------
</pre><p> First, the client elicits the frame stream via <code>MKE_REQUEST_START_FRAME_PUSH</code> request. If the sensor is ready to start sending the frame stream, it will reply with the <code>MKE_REPLY_DATA_WILL_START</code> data packet along with the corresponding <code>reqid</code> value. This data packet will not yet contain any frame data. After this initial reply, the sensor will start sending every available frame in a separate reply data packet with reply type <code>MKE_REPLY_DATA_WILL_CONTINUE</code>. Once the client decides to stop the frame stream, it issues the <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request. After this request, the client may still receive one or more <code>MKE_REPLY_DATA_WILL_CONTINUE</code> replies with frame data, as some may have already been send before the sensor received the <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request. The fact that the stream was stopped is signaled by the <code>MKE_REPLY_DATA_STOPPED</code> reply. Once this reply is received, it is guaranteed that no more <code>MKE_REPLY_DATA_WILL_CONTINUE</code> requests will follow. Finally, however, not necessarily in this order, the sensor will also receive a <code>MKE_REPLY_OK</code> reply with <code>reqid</code> value corresponding to the <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Sensor Policies</h1>
<p>The MkE API does not allow the client to change the specific sensor parameters, such as exposure time, gain, etc. However, it provides a concept of <em>policies</em>. Policies are sets of predefined sensor parameters that are available to the client to chose from and set. The actual parameters are not exposed to the client via the MkE API. The policies are accessible via their names, <em>e.g.</em>, 'SUNLIGHT', 'INDOORS', <em>etc</em>. These names must not be longer than 8 ASCII characters and are sensor specific.</p>
<p>The current policy can be queried via the <code>MKE_REQUEST_GET_POLICY</code> request, see [](#subsec_mke_request_get_policy). The sensor policy can be changed via the <code>MKE_REQUEST_SET_POLICY</code> request, see [](#subsec_mke_request_set_policy). The list of the available sensor policies can be queried using the <code>MKE_REQUEST_LIST_POLICIES</code> request, see [](#subsec_mke_request_list_policies).</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Reference</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Request Type</h2>
<p>The following table lists the valid client requests (request types) and the respective numerical codes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Request type</em>   </td><td class="markdownTableBodyNone"><em>Numerical code</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_TERMINATE</code>   </td><td class="markdownTableBodyNone">10    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_FIRMWARE_INFO</code>   </td><td class="markdownTableBodyNone">11    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_DEVICE_INFO</code>   </td><td class="markdownTableBodyNone">12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_DEVICE_XML</code>   </td><td class="markdownTableBodyNone">13    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_STATE</code>   </td><td class="markdownTableBodyNone">20    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_SET_STATE</code>   </td><td class="markdownTableBodyNone">21    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_POLICY</code>   </td><td class="markdownTableBodyNone">22    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_SET_POLICY</code>   </td><td class="markdownTableBodyNone">23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_START_FRAME_PUSH</code>   </td><td class="markdownTableBodyNone">24    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_STOP_FRAME_PUSH</code>   </td><td class="markdownTableBodyNone">25    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_GET_FRAME</code>   </td><td class="markdownTableBodyNone">26    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_LIST_POLICIES</code>   </td><td class="markdownTableBodyNone">27    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REQUEST_UPLOAD_PACKAGE</code>   </td><td class="markdownTableBodyNone">2001   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md21"></a>
&lt;tt&gt;MKE_REQUEST_TERMINATE&lt;/tt&gt;</h3>
<p><code>MKE_REQUEST_TERMINATE</code> request is used to shutdown or reboot the sensor programatically. The following C-style structure <code>MkERequest_Terminate</code> describes the inner structure of request field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkERequest_Terminate {</div>
<div class="line">  uint32_t  method;</div>
<div class="line">  uint8_t   undefined[4];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest_Terminate</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t method</code>   </td><td class="markdownTableBodyNone">Method of termination, valid methods are <code>MKE_TERMINATE_BY_REBOOT</code> (Numerical code 1) and <code>MKE_TERMINATE_BY_SHUTDOWN</code> (Numerical code 2).   </td></tr>
</table>
<p>The sensor will reply with <code>MKE_REPLY_OK</code> status in the case it registered the request and is on its way to perform the termination action. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
&lt;tt&gt;MKE_REQUEST_GET_FIRMWARE_INFO&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_FIRMWARE_INFO</code> to query the sensor’s firmware version and various other information. The <code>MKE_REQUEST_GET_FIRMWARE_INFO</code> request has no parameters. This means that the bytes of the request’s <code>params</code> field should be set to zero. The following C-style structure <code>MkEReply_FirmwareInfo</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_FirmwareInfo {</div>
<div class="line">  int64_t   posix_time;</div>
<div class="line">  uint32_t  git_commit;</div>
<div class="line">  uint8_t   rt_ver_major;</div>
<div class="line">  uint8_t   rt_ver_minor;</div>
<div class="line">  uint8_t   rt_ver_patch;</div>
<div class="line">  uint8_t   fw_ver_major;</div>
<div class="line">  uint8_t   fw_ver_minor;</div>
<div class="line">  uint8_t   fw_ver_patch;</div>
<div class="line">  char      undefined[6];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_FirmwareInfo</code> structure has 8 valid fields with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int64_t posix_time</code>   </td><td class="markdownTableBodyNone">POSIX time in the time of firmware compilation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint32_t git_commit</code>   </td><td class="markdownTableBodyNone">Short git hash of the latest firmware commit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint8_t rt_ver_major</code>   </td><td class="markdownTableBodyNone">Runtime version - major part    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint8_t rt_ver_minor</code>   </td><td class="markdownTableBodyNone">Runtime version - minor part    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint8_t rt_ver_patch</code>   </td><td class="markdownTableBodyNone">Runtime version - patch part    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint8_t fw_ver_major</code>   </td><td class="markdownTableBodyNone">Firmware version - major part    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint8_t fw_ver_minor</code>   </td><td class="markdownTableBodyNone">Firmware version - minor part    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint8_t fw_ver_patch</code>   </td><td class="markdownTableBodyNone">Firmware version - patch part   </td></tr>
</table>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
&lt;tt&gt;MKE_REQUEST_GET_DEVICE_INFO&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_DEVICE_INFO</code> to query the sensor’s ID information. The <code>MKE_REQUEST_GET_DEVICE_INFO</code> request has no parameters. This means that the bytes of the request’s <code>params</code> field should be set to zero. The following C-style structure <code>MkEReply_DeviceInfo</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_DeviceInfo {</div>
<div class="line">  uint16_t  device_id;</div>
<div class="line">  char      unit_id[8];</div>
<div class="line">  char      undefined[14];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_DeviceInfo</code> structure has 2 valid fields with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t device_id</code>   </td><td class="markdownTableBodyNone">Identification code of the device. This value is shared with other devices of the same model.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>char unit_id[8]</code>   </td><td class="markdownTableBodyNone">Serial number of the device.   </td></tr>
</table>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
&lt;tt&gt;MKE_REQUEST_GET_DEVICE_XML&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_DEVICE_XML</code> to query the sensor’s ID information in the XML file format. This XML file is sensor specific and its content is not part of the MkE API.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
&lt;tt&gt;MKE_REQUEST_GET_STATE&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_STATE</code> to query the sensor’s current state. There are two states the sensor can be in. The following C-style enum lists these states and their respective numerical codes:</p>
<div class="fragment"><div class="line">enum MkEStateType {</div>
<div class="line">  MKE_STATE_IDLE = 1,</div>
<div class="line">  MKE_STATE_DEPTH_SENSOR = 2,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MKE_REQUEST_GET_STATE</code> request has no parameters. This means that the bytes of the request’s <code>params</code> field should be set to zero. The sensor will respond with <code>MkEReply</code> where <code>num_bytes</code> = 0. The following C-style structure <code>MkEReply_State</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_State {</div>
<div class="line">  uint32_t  state;</div>
<div class="line">  char      undefined[20];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_State</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t state</code>   </td><td class="markdownTableBodyNone">The current sensor’s state as a valid value of <code>MkEStateType</code>.   </td></tr>
</table>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
&lt;tt&gt;MKE_REQUEST_SET_STATE&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_SET_STATE</code> to change the sensor’s current state. The following C-style structure <code>MkERequest_SetState</code> describes the inner structure of request field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkERequest_SetState {</div>
<div class="line">  uint32_t  new_state;</div>
<div class="line">  uint8_t   undefined[4];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest_SetState</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t new_state</code>   </td><td class="markdownTableBodyNone">The new sensor’s state as a valid value of <code>MkEStateType</code>, see [](#subsec_mke_request_get_state).   </td></tr>
</table>
<p>The sensor will respond with <code>MkEReply</code> where <code>num_bytes</code> = 0. The reply field <code>status</code> will be set to <code>MKE_REPLY_OK</code> in the case the state has been successfully changed. The sensor will reply with <code>MKE_REPLY_CLIENT_REQUEST_DOES_NOT_APPLY</code> in the case the requested state is identical to the current state.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
&lt;tt&gt;MKE_REQUEST_GET_POLICY&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_POLICY</code> to query the current sensor policy, see <a href="#subsec_sensor_policies">Sensor Policies</a>. The <code>MKE_REQUEST_GET_POLICY</code> request has no parameters. This means that the bytes of the request’s <code>params</code> field should be set to zero. The following C-style structure <code>MkEReply_GetPolicy</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_GetPolicy {</div>
<div class="line">  char      profile_name[8];</div>
<div class="line">  char      undefined[16];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_GetPolicy</code> structure has one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>char policy_name[8]</code>   </td><td class="markdownTableBodyNone">Name of the current policy as a C-style string, <em>i.e.</em>, zero terminated string. In the case the name is exactly 8 characters long, the terminating zero character is not added.   </td></tr>
</table>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
&lt;tt&gt;MKE_REQUEST_SET_POLICY&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_SET_POLICY</code> to set the sensor policy, see <a href="#subsec_sensor_policies">Sensor Policies</a>. The following C-style structure <code>MkERequest_SetPolicy</code> describes the inner structure of request field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkERequest_SetPolicy {</div>
<div class="line">  char      policy_name[8];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest_SetPolicy</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>char policy_name[8]</code>   </td><td class="markdownTableBodyNone">Name of the policy to set as a C-style string, <em>i.e.</em>, zero terminated string. In the case the name is exactly 8 characters long, the terminating zero character is not added. Use <code>MKE_REQUEST_LIST_POLICIES</code> to query the available policies, see [](#subsec_mke_request_list_policies).   </td></tr>
</table>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
&lt;tt&gt;MKE_REQUEST_LIST_POLICIES&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_LIST_POLICIES</code> to list the available policies. The <code>MKE_REQUEST_LIST_POLICIES</code> request has no parameters, <em>i.e.</em>, the bytes of the request’s <code>params</code> field should be set to zero.</p>
<p>The following C-style structure <code>MkEReply_ListPolicies</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_ListPolicies {</div>
<div class="line"> uint32_t  num_policies;</div>
<div class="line"> char      undefined[20];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_ListPolicies</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t num_policies</code>   </td><td class="markdownTableBodyNone">The number of available sensor specific policies.   </td></tr>
</table>
<p>The actual names of the policies are provided via the reply’s data payload signaled by non-zero reply field <code>num_bytes</code>. This data payload will contain a zero-byte separated list of <code>num_policies</code> policy names.</p>
<p>In the case of success, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
&lt;tt&gt;MKE_REQUEST_START_FRAME_PUSH&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_START_FRAME_PUSH</code> type to elicit frame stream from the sensor. The structure of the request’s <code>params</code> field is described by the C-style structure <code>MkERequest_GetFrame</code>, see [](#subsec_mke_request_get_frame).</p>
<p>If the sensor is ready to start sending the frame stream, it will reply with <code>MKE_REPLY_DATA_WILL_START</code> data packet with the corresponding <code>reqid</code> value. This data packet will not yet contain any frame data. After this initial reply, the sensor will start sending every available frame in a separate reply data packet with reply type <code>MKE_REPLY_DATA_WILL_CONTINUE</code>. These data packets will contain 3D data frames, see <a href="#subsec_3d_data_frame">3D Data Frame</a>.</p>
<p>The frame stream will end with a <code>MKE_REPLY_DATA_STOPPED</code> reply, if it has been correctly stopped by a <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request. Otherwise it will stop with an error reply.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
&lt;tt&gt;MKE_REQUEST_STOP_FRAME_PUSH&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_STOP_FRAME_PUSH</code> type to stop the frame stream elicited by previous <code>MKE_REQUEST_START_FRAME_PUSH</code> request. <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request has no parameters. This means that the bytes of the request’s <code>params</code> field should be set to zero. The sensor will respond with <code>MkEReply</code> where <code>num_bytes</code> = 0. If successful, the sensor will reply with <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
&lt;tt&gt;MKE_REQUEST_GET_FRAME&lt;/tt&gt;</h3>
<p>Use <code>MKE_REQUEST_GET_FRAME</code> type to request a single frame from the sensor. The sensor can request frame items of two types. The following C-style enum lists their respective numerical codes:</p>
<div class="fragment"><div class="line">enum MkEFrameType {</div>
<div class="line">  MKE_FRAME_TYPE_1 = 1,</div>
<div class="line">  MKE_FRAME_TYPE_2 = 2,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The following C-style structure <code>MkERequest_GetFrame</code> describes the inner structure of request field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkERequest_GetFrame {</div>
<div class="line">  uint16_t  frame_type;</div>
<div class="line">  uint8_t   undefined[6];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest_GetFrame</code> structure has only one valid field with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16_t frame_type</code>   </td><td class="markdownTableBodyNone">The requested frame type as a valid value of <code>MkEFrameType</code>.   </td></tr>
</table>
<p>The sensor will not respond to <code>MKE_REQUEST_GET_FRAME</code> request until a new frame is available. If successful, the sensor will reply with the <code>MKE_REPLY_OK</code> status. Otherwise, the sensor will reply with an error reply status, see <a href="#subsec_reply_status">Reply Status</a>.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
&lt;tt&gt;MKE_REQUEST_UPLOAD_PACKAGE&lt;/tt&gt;</h3>
<p>The <code>MKE_REQUEST_UPLOAD_PACKAGE</code> request is used to upload general variable-sized data to the sensor. The format and interpretation of the uploaded data is not part of the MkE API. In practice, this request is used to upload firmware binary package or other updates. The size of the uploaded data may be limited by the sensor. The <code>MKE_REQUEST_UPLOAD_PACKAGE</code> request is available only in the <code>MKE_STATE_IDLE</code> state.</p>
<p>The following C-style structure <code>MkERequest_UploadPackage</code> describes the inner structure of request field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkERequest_UploadPackage {</div>
<div class="line">  uint32_t  payload_size;</div>
<div class="line">  uint32_t  crc32;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkERequest_UploadPackage</code> structure has two valid fields with the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t payload_size</code>   </td><td class="markdownTableBodyNone">Size of the data payload in bytes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint32_t crc32</code>   </td><td class="markdownTableBodyNone">CRC-32 checksum (ITU-T V.42) of the data payload   </td></tr>
</table>
<p>The <code>MKE_REQUEST_UPLOAD_PACKAGE</code> request must be immediately followed by <code>payload_size</code> bytes of the payload.</p>
<p>If successful, the sensor will reply with the <code>MKE_REPLY_OK</code> status. In the case the payload size surpasses the request payload size limit of the server, the <code>MKE_REPLY_CLIENT_REQUEST_PAYLOAD_TOO_LONG</code> will be returned. If the sensor fails to validate the CRC-32 checksum, the <code>MKE_REPLY_CLIENT_MALFORMED_REQUEST</code> reply will be returned. Otherwise, the sensor will reply with <code>MKE_REPLY_SERVER_ERROR</code> error reply status.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Reply Status</h2>
<p>The sensor replies are conceptually divided into four classes:</p>
<p>1xx <br  />
 Replies with numerical codes 1xx are reserved for frame stream replies, see <a href="#subsec_requesting_frames">Requesting Frames</a>.</p>
<p>2xx <br  />
 Replies with numerical codes 2xx signalize successful completion of the reply.</p>
<p>4xx <br  />
 Replies with numerical codes 4xx signalize client side errors.</p>
<p>5xx <br  />
 Replies with numerical codes 5xx signalize server side errors.</p>
<p>The following table lists the valid sensor reply statuses and the respective numerical codes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Reply status</em>   </td><td class="markdownTableBodyNone"><em>Numerical code</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_DATA_WILL_START</code>   </td><td class="markdownTableBodyNone">100    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_DATA_WILL_CONTINUE</code>   </td><td class="markdownTableBodyNone">101    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_DATA_STOPPED</code>   </td><td class="markdownTableBodyNone">102    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_OK</code>   </td><td class="markdownTableBodyNone">200    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_CLIENT_ERROR</code>   </td><td class="markdownTableBodyNone">400    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_CLIENT_MALFORMED_REQUEST</code>   </td><td class="markdownTableBodyNone">401    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_CLIENT_ILLEGAL_REQUEST_TYPE</code>   </td><td class="markdownTableBodyNone">402    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_CLIENT_REQUEST_DOES_NOT_APPLY</code>   </td><td class="markdownTableBodyNone">403    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_CLIENT_REQUEST_PAYLOAD_TOO_LONG</code>   </td><td class="markdownTableBodyNone">404    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_SERVER_ERROR</code>   </td><td class="markdownTableBodyNone">500    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_SERVER_REQUEST_INTERRUPTED</code>   </td><td class="markdownTableBodyNone">501    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_SERVER_BUSY</code>   </td><td class="markdownTableBodyNone">502    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_REPLY_SERVER_INSUFFICIENT_RESOURCES</code>   </td><td class="markdownTableBodyNone">503    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_REPLY_SERVER_FATAL_ERROR</code>   </td><td class="markdownTableBodyNone">504   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md35"></a>
&lt;tt&gt;MKE_REPLY_DATA_WILL_START&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_DATA_WILL_START</code> reply signals the successful initialization of the frame streaming process. The data packet does not yet contain any data. At least one more reply will follow.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
&lt;tt&gt;MKE_REPLY_DATA_WILL_CONTINUE&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_DATA_WILL_CONTINUE</code> reply signals that the frame stream will continue with at least one more data packet. At the same time the data payload of the reply contains the 3D frame data.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
&lt;tt&gt;MKE_REPLY_DATA_STOPPED&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_DATA_STOPPED</code> reply signalizes that the frame stream has been successfully stopped via <code>MKE_REQUEST_STOP_FRAME_PUSH</code> request. This data packet does not contain any data payload. No more data packets pertinent to this frame stream will follow.</p>
<h3><a class="anchor" id="autotoc_md38"></a>
&lt;tt&gt;MKE_REPLY_OK&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_OK</code> reply status signals that a request has been successfully handled. No more data packet will follow <code>MKE_REPLY_OK</code> reply.</p>
<h3><a class="anchor" id="autotoc_md39"></a>
&lt;tt&gt;MKE_REPLY_CLIENT_ERROR&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_CLIENT_ERROR</code> reply signals a general client side error.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
&lt;tt&gt;MKE_REPLY_CLIENT_MALFORMED_REQUEST&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_CLIENT_MALFORMED_REQUEST</code> reply signals a sensor’s problem with parsing a request. For example, the field <code>magik</code> of <code>MkERequest</code>, see <a href="#subsec_request">Request</a>, does not contain string <code>MKERQ100</code>, or a request parameters are out of bounds.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
&lt;tt&gt;MKE_REPLY_CLIENT_ILLEGAL_REQUEST_TYPE&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_CLIENT_ILLEGAL_REQUEST_TYPE</code> reply signals that the client issued a request type not available in the current state. <a href="#apistates">Figure 1</a> lists the available sensor states and pertinent requests types.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
&lt;tt&gt;MKE_REPLY_CLIENT_REQUEST_DOES_NOT_APPLY&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_CLIENT_REQUEST_DOES_NOT_APPLY</code> reply signals a situation where a client requested resources that were not available in the sensor’s current state. For example, the client issued <code>MKE_REQUEST_GET_FRAME</code> request while in <code>MKE_STATE_IDLE</code> state.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
&lt;tt&gt;MKE_REPLY_CLIENT_REQUEST_PAYLOAD_TOO_LONG&lt;/tt&gt;</h2>
<p>The <code>MKE_REPLY_CLIENT_REQUEST_PAYLOAD_TOO_LONG</code> reply signals that the <code>MKE_REQUEST_UPLOAD_PACKAGE</code> request payload size surpassed the maximum request payload size allowed by the server.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
&lt;tt&gt;MKE_REPLY_SERVER_ERROR&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_SERVER_ERROR</code> reply signals a general sensor side error.</p>
<h3><a class="anchor" id="autotoc_md45"></a>
&lt;tt&gt;MKE_SERVER_REQUEST_INTERRUPTED&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_SERVER_REQUEST_INTERRUPTED</code> reply signals that a sensor’s work on a reply has been externally interrupted. For example, the client requested a state change from <code>MKE_STATE_DEPTH_SENSOR</code> to <code>MKE_STATE_IDLE</code>, but did not correctly stop an ongoing frame stream via <code>MKE_REQUEST_STOP_FRAME_PUSH</code>.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
&lt;tt&gt;MKE_REPLY_SERVER_BUSY&lt;/tt&gt;</h3>
<p>The sensor will issue the <code>MKE_REPLY_SERVER_BUSY</code> reply in situations where the client requests an operation that is already being processed by the sensor. For example, the client issued two <code>MKE_REQUEST_START_FRAME_PUSH</code> requests without correctly stopping the first one via <code>MKE_REQUEST_STOP_FRAME_PUSH</code>.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
&lt;tt&gt;MKE_REPLY_INSUFFICIENT_RESOURCES&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_INSUFFICIENT_RESOURCES</code> reply signals a fatal problem with memory resources on the sensor’s side. This reply data packet is "read-only", i.e., the sensor is unable to set <code>reqid</code> and <code>status</code> fields, see <a href="#subsec_reply">Reply</a>, before sending the reply data packet. This problem might be caused, for example, by quickly sending several requests without waiting for the sensor’s reply. The inner request queue is limited in length and the sensor will issue <code>MKE_REPLY_INSUFFICIENT_RESOURCES</code> reply in the case it is full. Once the sensor has processed any outstanding items in this queue, it will be ready to receive new requests, again.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
&lt;tt&gt;MKE_REPLY_SERVER_FATAL_ERROR&lt;/tt&gt;</h3>
<p>The <code>MKE_REPLY_SERVER_FATAL_ERROR</code> reply signals a fatal problem encountered during the sensor startup and runtime. This problem may have been caused by hardware issues or by an unsuccessful firmware update. The <code>MKE_REPLY_SERVER_FATAL_ERROR</code> reply contains another supplementary error code specifying the problem. The following C-style structure <code>MkEReply_ServerFatal</code> describes the inner structure of <code>MkEReply</code> field <code>params</code>:</p>
<div class="fragment"><div class="line">struct MkEReply_ServerFatal {</div>
<div class="line">  uint32_t  err_code;</div>
<div class="line">  char      undefined[20];</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>MkEReply_ServerFatal</code> structure has only one valid field:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Field</em>   </td><td class="markdownTableBodyNone"><em>Definition</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32_t err_code</code>   </td><td class="markdownTableBodyNone">Supplementary error code specifying the problem as a valid value of <code>MkEFatalErrorType</code>.   </td></tr>
</table>
<p>The following C-style <code>MkEFatalErrorType</code> enum lists possible values of <code>err_code</code>:</p>
<div class="fragment"><div class="line">enum MkEFatalErrorType {</div>
<div class="line">  MKE_FATAL_UNDEF               = 0,</div>
<div class="line">  MKE_FATAL_BADCONFIG           = 1,</div>
<div class="line">  MKE_FATAL_DETECTORINIT        = 2,</div>
<div class="line">  MKE_FATAL_BADCAMERA           = 3,</div>
<div class="line">  MKE_FATAL_RUNTIME             = 4,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The meaning of the supplementary error <code>err_code</code> is listed in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>Enum string</em>   </td><td class="markdownTableBodyNone"><em>Numerical code</em>   </td><td class="markdownTableBodyNone"><em>Meaning</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_FATAL_UNDEF</code>   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Unspecified fatal error    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_FATAL_BADCONFIG</code>   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Corrupted device configuration    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_FATAL_DETECTORINIT</code>   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Unable to initialize the detector    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MKE_FATAL_BADCAMERA</code>   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">The device has encountered a problem with the camera connection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MKE_FATAL_RUNTIME</code>   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Unspecified fatal error during runtime   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
